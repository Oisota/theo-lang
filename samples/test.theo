/*
 * Main Test File for Theo
 */

import (
	"std/io" // standard library import
	"std/math" * // import everything into current namespace
	"std/crypto" foo // import alias
	"cinclude/stdio" // include a c lib
	"app/models" // top level app namespace
	"./util" // relative import
)

fun main() int {
	let x = 5 * 8
	let hello = "Hello, World!"
	let result = scope x {
		x + 10
	}
	io.print(hello)
	io.print('Hello Again!')

	let l1 = List[int]()
	let el = l1[0]

	let l2 = l1.map(fun(a int) { a * 2 })
	let l2 = l1.map(fn a => a * 2 ) // still playing around with lambda syntax, this relies on inferring types from the list type

	// need to figure out how to lex different literals, may not be needed for initial implementation (should be working)
	let u2 = 0xFF
	let u3 = 0b0101

	with(open('file.txt'), fun(foo) {
		// do stuff with foo here
		let data = foo.read()
		data.map(fn l => int(l) * 2)
			.sum()
	})

	0
}
fun loop_test() {
	let i = Mut[int]()
	let j = 23.32
	let k = 10_000
	while i < 10 {
		i := i + 1 // make mutation require a special operator?
	}
}
// this is a comment
fun add(a int, b int) int { // looks a little cleaner without colons in function signature
	a+ b
}
fun fib(n int) int {
	case n {
		0 => 0
		1 => 1
		n => fib(n-1) + fib(n-2)
	}
}
/*
This is a multiline
comment
*/

struct Point {
	x float = 0
	y float = 0
}

let p1 = Point(x=5, y=6)
let p2 = Point(x=5, y=6)

fun distance(p1 Point, p2 Point) float {
	let a = math.abs(p1.x - p2.x)
	let b = math.abs(p1.y - p2.y)
	math.sqrt(math.pow(a, 2), math.pow(b, 2))
}

interface Shape {
	fun area() int
}

enum Bool { True False}

union Option[T] {
	Some(T),
	None
}
