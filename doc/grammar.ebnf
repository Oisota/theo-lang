(* func EBNF Grammar *)
white_space   = { " " | "\t" | "\n" | "\r" } ;
space         = { " " | "\t" | "\n" | "\r" }+ ;
nonzero_digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; 
digit         = "0" | nonzero_digit ; 
letter        = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | 
                "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | 
                "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | 
                "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ; 
char          = letter | digit | symbol ; (* where symbol is any printable unicode symbol *)

id = ( letter | "_" ) , { letter | digit | "_" } ;

program = import , expr ;

(* imports *)
import_list = { string , white_space };
import = "import" , white_space , "(" , white_space , import_list , white_space , ")";

(* type literals *)
int    = digit | ( nonzero_digit , { digit } ) ;
float  = int , "." , int ;
number = [ "~" ] , ( int | float ) ;

string = ( '"' , { char } , '"' ) 
       | ( "'" , { char } , "'" ) ;

literal = int | float | string;

collection_access = expr , "[" , expr , "]" ;

expr_block = "{" , { expr } , "}";

(* functions *)
param = id , white_space , id , [ "," ];
param_list = { param } ,;
func_sig = "fun", space , id , "(", param_list ")" , white_space , id ;
func_def = func_sig , white_space , expr_block;
func_call = expr , white_space , "(" , expr_list , ")" ;

(* with expression *)
with_expr = "with", space , id , "=", id , white_space , expr_block  ;

(* if else expression*)
if_expr = "if", space , id , "=", id , white_space , expr_block , "else" , white_space , expr_block ;

(* case expression *)
case_pattern = id , white_space , "(" , id_list , ")"; (* TODO define this *)
case_list = { case_pattern , "=>" , expr };
case_expr = "case", space , expr , white_space , "{" , case_list , "}" ;

(* assignment expression *)
type_annotation = ":" , white_space , id ;
assign_expr = "let" id , white_space , type_annotation , white_space , "=" , white_space , expr ;

(* interfaces *)
interface_body =;
interface = "interface" , white_space , id , "{" white_space , interface_body , white_space ,"}";

(* structs *)
struct_body = { id , white_space , id , [ "=" , expr ] };
struct = "struct" , white_space , id , "{" white_space , struct_body , white_space ,"}";

(* impl *)
impl_body = { func_def } ;
impl = "impl" , [ white_space , id ] , white_space , "for" , white_space , id , "{" , impl_body , "}";

(* enums *)
enum_body = { id , [ "(" , param_list , ")" ] };
enum = "enum" , white_space , id , "{" white_space , enum_body , white_space ,"}";

(* type alias*)
type_alias = "type" , white_space , id , white_space , "=" , white_space , id;

type_definition = interface | struct | impl | enum | type_alias;

(* Loops *)
id_list = { id , white_space }; 
for_loop = "for" , white_space , id_list , white_space , "in" , white_space , expr , white_space , expr_block;
while_loop = "while" , white_space , expr , white_space , expr_block;
loop_expr = for_loop | while_loop ;

(* operators *)
binary_operator = "==" 
	| "!=" 
	| "<" 
	| ">" 
	| "<="
	| ">="
	| "and"
	| "or"
	| "xor"
	| "+" 
	| "-"
	| "*"
	| "/"
	| "." ;

unary_operator = "not" ;

(* grand unifying expression *)
expr = expr , operator , expr
	| unary_operator , expr
	| if_expr
	| case_expr
	| with_expr
	| assign_expr
	| func_def 
	| func_call
	| type_definition
	| loop
	| collection_access