(* func EBNF Grammar *)
white_space   = { " " | "\t" | "\n" | "\r" } ;
space         = { " " | "\t" | "\n" | "\r" }+ ;
nonzero_digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; 
digit         = "0" | nonzero_digit ; 
letter        = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | 
                "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | 
                "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | 
                "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ; 
char          = letter | digit | symbol ; (* where symbol is any printable unicode symbol *)

id = ( letter | "_" ) , { letter | digit | "_" } ;

program = expr ;

(* type literals *)
int    = digit | ( nonzero_digit , { digit } ) ;
float  = int , "." , int ;
number = [ "~" ] , ( int | float ) ;

string = ( '"' , { char } , '"' ) 
       | ( "'" , { char } , "'" ) ;
tuple  = "(" , white_space , expr_list , white_space , ")" ;
list   = "[" , white_space , expr_list , white_space , "]" ;
vector = "<" , white_space , expr_list , white_space , ">" ;
set    = "#{" , white_space , expr_list , white_space , "}" ;

dict = "{" , white_space , key_value_list , white_space , "}" ;
key_value_list = key_value_pair | key_value_pair "," key_value_list ;
key_value_pair = expr , white_space , ":" , white_space , expr ;

collection_access = ( id | collection ) , "[" , value , "]" ;


lambda = "fn" , space , id_list "=>" , expr ;
expr_block = "{" , { expr } , "}";

function = "fun", space , id , "(", param_list ")" , white_space , ":" , id , expr_block ;


func_call = expr , white_space , "(" , expr_list , ")" ;


assign_expr = "let" ( id | object_property ) , white_space , "=" , white_space , expr ;

decl_list = { decl } ;
decl      = type , white_space , id_list ;

expr_block = "{" , expr_list , "}" ;
expr      = expr_block | math_expr | bool_expr ;

(* == != < > <= >= && || ! *)
binary_operator = "==" 
	| "!=" 
	| "<" 
	| ">" 
	| "<="
	| ">="
	| "and"
	| "or"
	| "xor"
	| "+" 
	| "-"
	| "*"
	| "/"
	| "." ;

unary_operator = "not" ;

(* TODO need to just defin *)
expr = expr , operator , expr
	| unary_operator , expr
	| if_expr
	| case_expr
	| assign_expr
	| func_expr 
	| func_call ;

